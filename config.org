#+title: Literate configuration for emacs
#+startup: content

* Install/Reinstall packages
To make things more portable when you set up a new machine and want to
import your configuration you could set the variable
package-selected-package to the packages you use, and execute
~package-install-selected-packages~ to install the packages in the new
emacs or reinstall if you had a problem thinkering with your
configuration.

#+BEGIN_SRC emacs-lisp
  (setq package-selected-packages '(projectile rjsx-mode js2-mode
					       yasnippet-snippets
					       yasnippet web-mode
					       which-key lsp-mode
					       dracula-theme company
					       yaml-mode yaml-pro yaml))
					       #+END_SRC
* Look and feel
** UI customizations
*** UI
You can disable some UI parts of emacs to have a more clean look, you
can achieve that disabling the tool bar, scroll bar and the menu bar
with =tool-bar-mode=, =scroll-bar-mode= and =menu-bar-mode=
respectively.
#+begin_src emacs-lisp
(tool-bar-mode 0)
(scroll-bar-mode 0)
(menu-bar-mode 0)
#+end_src

*** Font
About the font, emacs can display various fonts in various part of the
emacs ui, so you can set a font for some buffers or set a font for the
modline, or for the entire frame (in emacs the 'window' of the program
is called frame, windows are the open files that you have when you
split the view of two or the same file, and a buffer is the thing
between the frame and the modeline). simply in this config I set a
font for all of emacs with =(set-face-attribute)= in emacs are
multiple ways to set a font so if you want to know more there's a wiki
page about it.  [[https://www.emacswiki.org/emacs/SetFonts]]

#+begin_src emacs-lisp
(set-face-attribute 'default nil :font "Input Mono Narrow" :height 120)
(set-face-attribute 'line-number nil :inherit 'fixed-pitch)
#+end_src

*** Theme
Setting a color theme.  Set a color with with M-x =load-theme= and
press tab to see a list of available themes, with c-n and c-p you move
to the theme you want and with enter or return select the theme, also
if you like menus you can use M-x =customize-themes= and set a color
theme from there, but if you have a configuration file like this
sometimes the use of =customize= can break some things in your init
file so be aware.

For the color theme to be permanent use the function =load-theme= in
your configuration file just put the name of the theme, in the code
next the =t= is to tell emacs that you dont want user confirmation to
load the theme, this happens because third party themes sometimes are
not 'safe' for emacs so when you setted up a theme in your config file
at startup emacs always ask for confirmation to load the theme so the
=t= is for not askin confirmation to load the theme.

#+begin_src emacs-lisp
(load-theme 'modus-operandi t)
(setq modus-themes-mixed-fonts t)

;; Transparent background
(set-frame-parameter nil 'alpha-background 90)
(add-to-list 'default-frame-alist '(alpha-background . 90))
#+end_src

remember if you have a theme enabled and you want to test other themes
with =load-theme= be aware that emacs can enable multiple themes at
the same time, so you must disable the theme that you are already
using to not create sort like a mixture of both themes. You can do
this with M-x =disable-theme= and selecting the theme you want to
disable.

** Behavior customizations
*** Line and column numbers.
I like to have line numbers for almost everything so
=global-display-line-numbers-mode= is for that, but I only
wanted enabled in code files so better just enable ~display-line-numbers-mode~
when prog-mode is enable. Also recently discover
in vim you can have relative line numbers, this mean that each line is
numbered relative to the cursor's current position and show the
/distance/ to that line so for example if you go to the top of the
file the cursor will be marked in the line 1 (this in emacs, in other
editor may vary) and the next line numbers will be the amount of
numbers to /get/ to that line so if the current cursor position is in
the line 1 to get to line 2 you just need to move one line down, to
get to the line 5 you'll need to move 4 line down, and so on. Also
this apply for lines above the cursor, following the previous example
if the cursos position is in the line 5 the lines above the cursor
will show 1, 2, 3 and 4 so for getting to the line 1 you need to move
4 lines up.

Also its useful to know the number of columns that the text has inside
the buffer so It'll be displayed the column number of the cursor in
the modeline, very useful in code 


#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative) ;;relative line numbers
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
(set-face-attribute 'line-number nil :inherit 'fixed) ;;Make the face of the line numbers always fixed-pitch
(column-number-mode 1) ;;display columns in the modeline
#+end_src

*** The cursor.
I like the bar cursor '|', the default cursor emacs is the block 'â–ˆ'
(in unicode is U+2588) to change it you need to set the variable
=cursor-type= to the type of cursor avilable in emacs in my case is
bar, is you want to know other values acepted for =cursor-type= you
can do C-h v cursor-typpe inside emacs
#+begin_src emacs-lisp
(setq-default cursor-type 'bar)
#+end_src

*** Parenthesis (brackets and braces).
Emacs has a mode called "show-paren-mode" that highlights matching
parentheses, brackets, and braces.
Electric pair mode is a mode to have automatic closing symbols /{},[],"",'',()/
#+begin_src emacs-lisp
(show-paren-mode 1)
(electric-pair-mode 1)
#+end_src

*** Ido.
Ido means Interactively Do things it's a package built in emacs that
gives you more things to do with your buffers, In comands like
find-file or dired gives you options for what you may want to search
or do.
#+begin_src emacs-lisp
(setq ido-enable-flex-matching t
      ido-everywhere t
      ido-create-new-buffer 'always
      ido-ignore-extensions t)
(setq-default confirm-nonexistent-file-or-buffe nil)
(ido-mode 1)
#+end_src

*** Disable backup files
Disable backup and lock files and update files automatically
#+begin_src emacs-lisp
(setq make-backup-files nil
      backup-inhibited t)
(global-auto-revert-mode 1)
(setq global-auto-revert-non-file-buffers t)
#+end_src

*** Save place and change the "customization location"
Remember the last place you visited in a file
#+begin_src emacs-lisp
(save-place-mode 1)
#+end_src

Changing the location of the "Custom file".
Sometimes emacs put "custom "code into the init file. I don't that to happen
so.
#+begin_src emacs-lisp
(setq custom-file (locate-user-emacs-file "custom-vars.el"))
#+end_src

* Melpa
Emacs only has the GNU Elpa repositories (free software) by default,
if you want more packages Melpa is good for that, since most of the
popular packages are there.

#+BEGIN_SRC emacs-lisp
;; use melpa
(require 'package) (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+end_src

* Project Management
Just use project.el
* Wich Key
Which key is a help for when you know the key combinations of certain
commands so when you type a key that is part of a conjuction of keys
for a command which key will show you a window in the bottom of the
screen showing you the key combinations to do a command. Very useful
if you are new to emacs.

#+BEGIN_SRC emacs-lisp
  ;;which key
  (require 'which-key)
  (which-key-mode)
  (which-key-setup-side-window-bottom)
#+END_SRC

* Company Mode
Provides a little popup for autocompletion like and IDE or vscode or
kate.
#+BEGIN_SRC emacs-lisp
  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-/") #'company-complete))
  (with-eval-after-load 'company-complete
    (define-key company-active-map
      (kbd "TAB")
      #'company-complete-common-or-cycle)
    (define-key company-active-map
      (kbd "<backtab>")
      (lambda ()
	(interactive)
	(company-complete-common-or-cycle -1))))
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-.") #'company-show-location)
    (define-key company-active-map (kbd "RET") nil))
  #+END_SRC

* Org mode
** Start org mode with folded elements
Org mode has the ability of fold parts of theor document, when i load
this config I liked to have it folded so I can have easy acces to
every part of the config without using much C-n and C-p.
#+BEGIN_SRC emacs-lisp
  (setq org-startup-folded nil) ;;change for now
#+END_SRC

** Better defaults for org-mode
Org-mode by default is a little bit anoying in some areas so the next
code its mean to "fix" them.
#+begin_src emacs-lisp
  (setq org-src-preserve-indentation t	;Preserva indentacion original
	org-edit-src-content-indentation 0 ;No agregar indentacion adicional
	org-src-tab-acts-natively t	 ; Usa la tecla tab para indentar codigo
	org-src-fontify-natively t	 ; Resalta sintaxis en bloques de codigo
	org-src-tab-indent t)		 ; Indenta codigo con tab
#+end_src

** Heading sizes and more
All the headings have the same size also the text is not aligned with his
heading by default so to change the heading sizes and align the text with
the coresponding header.
*** Custom heading sizes
#+begin_src emacs-lisp
;; Configurar estilos para los niveles de encabezados
(dolist (level '((1 . 1.4) (2 . 1.2) (3 . 1.1) (4 . 1.0) (5 . 0.9)))
  (set-face-attribute (intern (format "org-level-%d" (car level))) nil
		      :inherit (intern (format "outline-%d" (car level)))
		      :height (cdr level)))

;; Config de estilo para el titulo del documento org
(set-face-attribute 'org-document-title nil :height 2.0)

;; Ajustar el texto a su encabezado
;; (defun my/write-prose ()
;;   (variable-pitch-mode 0)
;;   (set-face-attribute 'org-indent nil :inherit '(org-hide variable-pitch))
;;   (set-face-attribute 'org-hide nil :inherit 'fixed-pitch))

;; (add-hook 'org-mode-hook #'my/write-prose)
#+end_src

*** Custom face for code blocks
Also you can configure how code blocks look like with custom-set-faces or
set-face-attribute
#+begin_src emacs-lisp
(set-face-attribute 'org-block nil
                    :extend t
		    :foreground "foreground" ;;foreground "#ffb86c"
                    :slant 'italic)

(set-face-attribute 'org-block-begin-line nil
                    :extend t
                    :overline "foreground"
                    :underline '(:color foreground-color :style line :position t)
                    :slant 'italic
                    :weight 'bold)

(set-face-attribute 'org-block-end-line nil
                    :inherit 'org-block-begin-line
                    :extend t
                    :overline nil
                    :underline '(:color foreground-color :style line :position t))

;;Using custom-set-faces
;; (custom-set-faces
;;  '(org-block ((t (:extend t :foreground "#ffb86c" :slant italic))))
;;  '(org-block-begin-line ((t (:inherit org-meta-line :extend t :overline "foreground" :underline (:color foreground-color :style line :position t) :slant italic :weight bold))))
;;  '(org-block-end-line ((t (:inherit org-block-begin-line :extend t :overline nil :underline (:color foreground-color :style line :position t))))))

#+end_src

*** Mixed fonts
#+begin_src emacs-lisp
(set-face-attribute 'variable-pitch nil :family "Noto Sans" :height 1.0)
(set-face-attribute 'fixed-pitch nil :family "FiraCode Nerd Font" :height 1.0)
;;(set-face-attribute 'fixed-pitch nil :family "FiraCode Nerd Font" :height 0.9)

(custom-set-faces
 '(org-block ((t (:inherit fixed-pitch))))
 '(org-table ((t (:inherit fixed-pitch))))
 '(org-list-dt ((t (:inherit fixed-pitch))))
 '(org-list-dd ((t (:inherit fixed-pitch))))
 '(org-tag ((t (:inherit fixed-pitch))))
 '(org-quote ((t (:inherit fixed-pitch))))
 '(org-code ((t (:inherit fixed-pitch))))
 '(org-link ((t (:inherit fixed-pitch))))
 '(org-toc ((t (:inherit fixed-pitch))))
 '(org-formula ((t (:inherit fixed-pitch))))
 '(org-verbatim ((t (:inherit fixed-pitch))))
 '(org-strike ((t (:inherit fixed-pitch))))
 '(org-checkbox ((t (:inherit fixed-pitch))))
 '(org-list ((t (:inherit fixed-pitch))))
 '(org-meta-line ((t (:inherit fixed-pitch)))))

(add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

* Tree-Sitter
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
(setq major-mode-remap-alist
      '((c-mode . c-ts-mode)
	(c++-mode . c++-ts-mode)
	(yaml-mode . yaml-ts-mode)
	(conf-toml-mode . toml-ts-mode)))
#+end_src

* Keybindings
** Windows
This keybindings remaps some basics keys for managing windows in emacs (reseize, new windows, etc)
To resize windows you only can enlarge a window (vertical), make it wider or narrower.
- `c-x ^' makes the current window talle (`enlarge-window')
- `C-x }' makes it wider (â€˜enlarge-window-horizontallyâ€™)
- `C-x {' makes it narrower (â€˜shrink-window-horizontallyâ€™)

I remap those commands and using repeat mode to custom de repeat map to those command,
with ~global-set-key~ I create the new maps for managing the size of windows inside emacs and
nwith ~defvar resize-window-repeat-map~ define  a set of maps that repeated with activate a command.
Also with ~(put 'command 'repeat-map  'maps-defined-earlier)~ you asigns those maps to the
repeat maps that =repeat-mode= uses.

I also remap the comands to create new windows to ones of my linking, trying to not leave the home row
to much or at least stay more close to it.

Emacs can create windows sensibly, thats controlled by a funcion called ~split-window-sensibly~ this function
is called for example when you do =find-file-other-window= so it can decide where to create the new window,
for the function decided where to create a new window it uses 2 variables ~split-height-threshold~ and
~split-width-threshold~ to check if the current window has at least n columns or lines to be suitable
to create a new window, /if you know more on how in works you can get into detail checking the documetation of the
function/, in a nutshell if ~split-height-threshold~ is setted to a low value the new window will be opened below
the current windows, something similar happens with ~split-width-threshold~ but if this one is setted to a low value
/(like 50 I think)/ the new window it'll be opened to the left of the current window.

#+begin_src emacs-lisp
  (repeat-mode 1)

;;  (setq split-width-threshold 100)
  (global-set-key (kbd "C-x w t") 'enlarge-window) ;; t for taller
  (global-set-key (kbd "C-x w s") 'shrink-window)  ;; s for shrink
  (global-set-key (kbd "C-x w n") 'shrink-window-horizontally) ;; n for narrow
  (global-set-key (kbd "C-x w e") 'enlarge-window-horizontally) ;; e for enlarge

  (defun my/create-new-window (direction)
    "Create a new window based on DIRECTION if DIRECTION is 'vertical, do
    split-window-horizontally (new window on the on the right), otherwise do
    split-window-vertically (new window bellow) and move the cursor to that window."
    (interactive "sDirection (h for horizontal, v for vertical): ")
    (let ((split-func
	   (if (string= direction "v")
	       #'split-window-horizontally
	     (if (string= direction "h")
		 #'split-window-vertically
	       nil))))
      (when split-func
	(funcall split-func)
	(other-window 1))))

  (global-set-key (kbd "C-c wl") (lambda () (interactive) (my/create-new-window "v"))) ;; Create window on the right
  (global-set-key (kbd "C-c wd") (lambda () (interactive) (my/create-new-window "h"))) ;; Create window below
  (global-set-key (kbd "C-c fow") #'ido-find-file-other-window) ;; Find file in other window file-other-window
  (global-set-key (kbd "C-c dow") #'ido-dired-other-window) ;; Open dired in other window; dired-other-window
  (global-set-key (kbd "C-c cow") #'delete-other-windows) ;; Delete all the windows except the current window; close-other-windows
  (global-set-key (kbd "C-c wc") #'delete-window) ;; Close current window; window-close
  (global-set-key (kbd "M-o") #'other-window) ;; Change other window
  (global-set-key (kbd "C-c bow") #'ido-switch-buffer-other-window)

  (defvar my/resize-window-repeat-map
    (let ((map (make-sparse-keymap)))
      (define-key map "t" 'enlarge-window)
      (define-key map "s" 'shrink-window)
      (define-key map "n" 'shrink-window-horizontally)
      (define-key map "e" 'enlarge-window-horizontally)
      map)
    "Keymap to repeat resize window key sequences.")

  (dolist (cmd '(enlarge-window shrink-window shrink-window-horizontally enlarge-window-horizontally))
    (put cmd 'repeat-map 'my/resize-window-repeat-map))

#+end_src

* Speed Bar
Recently discover that emacs has a file tree integrated in emacs called speedbar is a little bit ugly
and it opens in another frame, so you can install a package called sr-speedbar that integrates
speedbar inside the emacs frame.
#+begin_src emacs-lisp
;; (use-package sr-speedbar
;;   :ensure t)

(setq speedbar-show-unknown-files t)
(setq sr-speedbar-width 30
      sr-speedbar-skip-other-window-p t)

;; To open move the cursor to the file you opened
(with-eval-after-load 'sr-speedbar
  (advice-add 'sr-speedbar-open :after
              #'(lambda ()
                  ;; Remove weird sr-speedbar hooks
                  (remove-hook 'speedbar-before-visiting-file-hook #'sr-speedbar-before-visiting-file-hook)
                  (remove-hook 'speedbar-before-visiting-tag-hook #'sr-speedbar-before-visiting-tag-hook)
                  (remove-hook 'speedbar-visiting-file-hook #'sr-speedbar-visiting-file-hook)
                  (remove-hook 'speedbar-visiting-tag-hook #'sr-speedbar-visiting-tag-hook))))

(add-hook 'emacs-startup-hook (lambda ()
  (sr-speedbar-open)
  ))

(global-set-key (kbd "C-M-0") 'sr-speedbar-toggle)
(global-set-key (kbd "M-0") 'sr-speedbar-select-window)
;; To keep speebar window width after resizing
;; (with-current-buffer sr-speedbar-buffer-name
;;   (setq window-size-fixed 'width))
#+end_src
